## Maze - generate, traverse, and solve mazes

### What is maze?

Maze is a 2D grid of cells. Each cell has 4 walls (top, right, bottom, left). Each wall can be either open or closed. A maze is generated by opening and closing walls between cells. A maze can be traversed by moving from cell to cell through open walls. A maze can be solved by finding a path from a start cell to an end cell.

### Model

We will use a model with the following classes:

* `MazeItem` - a point in 2D space, has x and y coordinates, can be visited or not visited, can be a wall or a cell (is a base class for `Cell` and `Wall`)
* `Cell` - a cell, always open for passage
* `Wall` - a wall, can be open or closed
* `Maze` - a maze is a 2D matrix of cells and walls, like this:
```
wall wall wall wall will
wall cell wall cell will
wall wall wall wall will
wall cell wall cell will
wall wall wall wall will
```

As we can see, in ths model the number of items (both walls and cells) in one dimension is always odd, and is equal to numberOfCells * 2 + 1.

### Generate

To generate a maze, we will use the following Python script from [this repository, containing maze generation codes in various languages](https://github.com/joewing/maze/blob/master/maze.py)

### Parse the generated maze

Generated maze should be saved to a file. See the format in `maze_sample.txt`. We will use this file to parse the maze, build a model, and solve it.

### Solve

As soon as we generated a maze, it becomes a graph. We can use graph search algorithms to find a path from start to end. We can use the following algorithms:

* [Breadth-first search](https://en.wikipedia.org/wiki/Breadth-first_search) (BFS)
* [Depth-first search](https://en.wikipedia.org/wiki/Depth-first_search) (DFS)
* [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) (Dijkstra)
* [A* search algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm) (A*)

### Complexity

* BFS: O(|V| + |E|)
* DFS: O(|V| + |E|)
* Dijkstra: O(|E| + |V|log|V|)
* A*: O(|E| + |V|log|V|)
where V is the number of vertices (nodes) and E is the number of edges in the graph.

### Optimize

The initial DFS search used random selection of the next cell to visit. This is not optimal, because it can lead to a situation when the path is very long. We can optimize the search by measuring the distance to the end cell and selecting the next cell to visit based on the distance. This will lead to a shorter path. Basically, we will use priorities similar to Dijkstra's algorithm.

### Alternative paths

Getting alternative paths is based on DFS algoritm. We have to randomize the selection of the next cell to visit, otherwise we will get the same path every time. The code gives 10 attempts to find an alternative path. If the path is duplicate, it is discarded, so the final list contains only unique paths. To display the list, it is sorted by path length.

### Visualize

The following ways to visualize the maze are implemented:

* display the unsolved maze in the console; it is useful for seeing the parsed maze,
* display the solved maze in the console; it is useful for seeing the path that was found,
* animated dispaly of the process of solving the maze,
* display the process of solving the maze frame by frame; it is useful for debugging search algorithms.

### Run the code

The code requires .NET 7. To run the code clone the repository, navigate to the solution root, and execute the following command:
```cmd
dotnet run --project src/MazeSolve
```
Alternatively, you can build the solution and run the executable:
```cmd
dotnet build
dotnet src/MazeSolve/bin/Debug/net7.0/MazeSolve.dll
```

### TODO

* [X] Optimize: measure distance to end in DFS and try selecting the shortest.
* [ ] Is it possibe to make path search multi-threaded? How to sync the paths?
* [ ] Is it possible to make path search distributed? Again, how to sync the paths? Storing in distributed cache?
